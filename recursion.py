# Factorial 
# 1! = 1
# 2! = 2*1
# 3! = 3*2*1
# 4! = 4*3*2*1
# 5! = 5*4*3*2*1

# Factorial without recursion
# def faktorial(num):
#     next=num-1
#     result=num
#     while next>0:
#         result=result*next
#         next-=1
#     return result

# number = faktorial(5)
# print(number)

# Factorial with recursion
def factorial(n):
    if n == 0:
        return 1  # Base case: factorial of 0 is 1
    else:
        return n * factorial(n - 1)  # Recursive case
# Example usage:
print(factorial(5))  # Output will be 120
# # my undestending: print(5*(4*(3*(2*(1)))))
# Рекурсивная функция всегда отрезает кусочек, который можно использовать без рекурсии, а оставшуюся часть загоняет опять в рекурсию и так до конца.
# кусочек = 'n * '
# И всегда в начале рекурсивной функции проверяется базовое значение.
# Это самое упрощённое значение, которое находится на конце спектра.
# Т.е. там где рекурсия должна уже прекратиться.
# базовым в данном случае нужно считать 0

# def sum_digits(n):
#     """Return the sum of the digits of positive integer n."""
#     if n < 10:
#         return n
#     else:
#         all_but_last = n // 10
#         last = n % 10
#         return sum_digits(all_but_last) + last
# опять напомню своё наблюдение(Рекурсивная функция всегда отрезает кусочек, который можно использовать без рекурсии, а оставшуюся часть загоняет опять в рекурсию и так до конца.
# кусочек = '+ last'
# И всегда в начале рекурсивной функции проверяется базовое значение.
# Это самое упрощённое значение, которое находится на конце спектра.
# Т.е. там где рекурсия должна уже прекратиться.)
# базовым в данном случае нужно считать числа меньше 10, т.е. однозначные.
# однозначное число не нужно складывать с чем-то, его просто нужно вернуть и закончить функцию
# print(sum_digits(51245))

